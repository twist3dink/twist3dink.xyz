import fs from "node:fs";
import path from "node:path";
import StyleDictionary from "style-dictionary";

import {
  ROOT,
  CORE_FILES,
  ALIASES_FILE,
  LIGHT_THEME_FILE,
  DARK_THEME_FILE,
  validateAllOrExit,
  sha256File
} from "./token-validation.mjs";

// Note: Style Dictionary buildPath is relative to process.cwd() unless absolute.
// Use an absolute path to make builds deterministic regardless of where the script is run.
const OUT_DIR = path.join(ROOT, "outputs");

// Experimental aliases are blocked unless explicitly enabled.
const ENABLE_EXPERIMENTAL = process.env.ENABLE_EXPERIMENTAL === "1";
const TOKENS_VERBOSE = process.env.TOKENS_VERBOSE === "1";

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function readFileOrThrow(p, { hint } = {}) {
  if (!fs.existsSync(p)) {
    const extra = hint ? `\n${hint}` : "";
    throw new Error(
      `Expected output was not generated: ${p}` +
        `\nThis typically indicates token collisions or a filter/source configuration that produced zero tokens.` +
        extra
    );
  }
  return fs.readFileSync(p, "utf8");
}

// 1) Validate tokens (schema + contracts) before building.
const {
  HAS_LIGHT_THEME,
  HAS_DARK_THEME
} = validateAllOrExit({ enableExperimental: ENABLE_EXPERIMENTAL });

// 2) Build outputs via Style Dictionary
ensureDir(OUT_DIR);

// We generate outputs for the *consumption* layer:
// semantic + context (+ themes), excluding base primitives and experimental aliases.
// Base is included for reference resolution only.
const isConsumptionToken = (token) => {
  const fp = token?.filePath || "";
  return (
    fp.endsWith(path.join("tokens", "semantic.json")) ||
    fp.endsWith(path.join("tokens", "context.json")) ||
    fp.endsWith(path.join("tokens", "themes", "light.json")) ||
    fp.endsWith(path.join("tokens", "themes", "dark.json"))
  );
};

// Custom TS output: `as const` + inferred types.
StyleDictionary.registerFormat({
  name: "ts/const",
  format: ({ dictionary, file }) => {
    const exportName = file?.options?.exportName || "tokens";
    const filterFn = typeof file.filter === "function" ? file.filter : () => true;
    const tokens = dictionary.allTokens.filter((t) => filterFn(t));

    const out = {};
    for (const t of tokens) {
      let cur = out;
      for (let i = 0; i < t.path.length; i++) {
        const k = t.path[i];
        if (i === t.path.length - 1) {
          cur[k] = t.value;
        } else {
          cur[k] = cur[k] || {};
          cur = cur[k];
        }
      }
    }

    const json = JSON.stringify(out, null, 2);
    return [
      "/* Auto-generated by Style Dictionary. Do not edit manually. */",
      `export const ${exportName} = ${json} as const;`,
      `export type ${exportName[0].toUpperCase() + exportName.slice(1)} = typeof ${exportName};`,
      ""
    ].join("\n");
  }
});

const cssFileFor = (destination, selector) => ({
  destination,
  format: "css/variables",
  filter: isConsumptionToken,
  options: {
    selector,
    prefix: "ds",
    // Consumption outputs are intended to be drop-in usable.
    // We therefore emit resolved literal values to avoid dependency on filtered-out base variables.
    outputReferences: false
  }
});

const tsFileFor = (destination, exportName) => ({
  destination,
  format: "ts/const",
  filter: isConsumptionToken,
  options: { exportName, outputReferences: false }
});

async function buildTheme({ theme, selector, themeFile, exportName }) {
  const source = [...CORE_FILES, ...(ENABLE_EXPERIMENTAL ? [ALIASES_FILE] : [])];
  if (themeFile) source.push(themeFile);

  const sd = new StyleDictionary({
    source,
    log: TOKENS_VERBOSE ? { verbosity: "verbose" } : undefined,
    platforms: {
      css: {
        transformGroup: "css",
        buildPath: OUT_DIR + path.sep,
        files: [cssFileFor(`tokens.${theme}.css`, selector)]
      },
      ts: {
        transformGroup: "js",
        buildPath: OUT_DIR + path.sep,
        files: [tsFileFor(`tokens.${theme}.ts`, exportName)]
      }
    }
  });

  await sd.buildAllPlatforms();
}

// Build light + dark when theme files exist; otherwise build single-theme defaults.
const hasBothThemes = HAS_LIGHT_THEME && HAS_DARK_THEME;
if (hasBothThemes) {
  await buildTheme({ theme: "light", selector: ":root", themeFile: LIGHT_THEME_FILE, exportName: "tokens" });
  await buildTheme({ theme: "dark", selector: '[data-theme="dark"]', themeFile: DARK_THEME_FILE, exportName: "tokensDark" });

  // Combine into single consumption outputs
  const css = [
    readFileOrThrow(path.join(OUT_DIR, "tokens.light.css"), {
      hint: 'Re-run with TOKENS_VERBOSE=1 to see collision details.'
    }),
    "",
    readFileOrThrow(path.join(OUT_DIR, "tokens.dark.css"), {
      hint: 'Re-run with TOKENS_VERBOSE=1 to see collision details.'
    }),
    ""
  ].join("\n");
  fs.writeFileSync(path.join(OUT_DIR, "tokens.css"), css);

  const ts = [
    readFileOrThrow(path.join(OUT_DIR, "tokens.light.ts"), {
      hint: 'Re-run with TOKENS_VERBOSE=1 to see collision details.'
    }),
    readFileOrThrow(path.join(OUT_DIR, "tokens.dark.ts"), {
      hint: 'Re-run with TOKENS_VERBOSE=1 to see collision details.'
    }),
    "",
    "export type Tokens = typeof tokens;",
    "export type TokensDark = typeof tokensDark;",
    ""
  ].join("\n");
  fs.writeFileSync(path.join(OUT_DIR, "tokens.ts"), ts);

  // Cleanup intermediates
  for (const f of ["tokens.light.css", "tokens.dark.css", "tokens.light.ts", "tokens.dark.ts"]) {
    fs.rmSync(path.join(OUT_DIR, f), { force: true });
  }
} else {
  await buildTheme({
    theme: "single",
    selector: ":root",
    themeFile: HAS_LIGHT_THEME ? LIGHT_THEME_FILE : null,
    exportName: "tokens"
  });
  fs.renameSync(path.join(OUT_DIR, "tokens.single.css"), path.join(OUT_DIR, "tokens.css"));
  fs.renameSync(path.join(OUT_DIR, "tokens.single.ts"), path.join(OUT_DIR, "tokens.ts"));
}

// Experimental outputs: only emit when explicitly enabled.
if (ENABLE_EXPERIMENTAL) {
  const isExperimentalToken = (token) => {
    const fp = token?.filePath || "";
    return fp.endsWith(path.join("tokens", "aliases.json"));
  };

  const cssExpFileFor = (destination, selector) => ({
    destination,
    format: "css/variables",
    filter: isExperimentalToken,
    options: { selector, prefix: "ds", outputReferences: false }
  });

  const tsExpFileFor = (destination, exportName) => ({
    destination,
    format: "ts/const",
    filter: isExperimentalToken,
    options: { exportName, outputReferences: false }
  });

  async function buildExperimentalTheme({ theme, selector, themeFile, exportName }) {
    const source = [...CORE_FILES, ALIASES_FILE];
    if (themeFile) source.push(themeFile);
    const sd = new StyleDictionary({
      source,
      log: TOKENS_VERBOSE ? { verbosity: "verbose" } : undefined,
      platforms: {
        css: {
          transformGroup: "css",
          buildPath: OUT_DIR + path.sep,
          files: [cssExpFileFor(`tokens.experimental.${theme}.css`, selector)]
        },
        ts: {
          transformGroup: "js",
          buildPath: OUT_DIR + path.sep,
          files: [tsExpFileFor(`tokens.experimental.${theme}.ts`, exportName)]
        }
      }
    });
    await sd.buildAllPlatforms();
  }

  if (hasBothThemes) {
    await buildExperimentalTheme({
      theme: "light",
      selector: ":root",
      themeFile: LIGHT_THEME_FILE,
      exportName: "tokensExperimental"
    });
    await buildExperimentalTheme({
      theme: "dark",
      selector: '[data-theme="dark"]',
      themeFile: DARK_THEME_FILE,
      exportName: "tokensExperimentalDark"
    });
    fs.writeFileSync(
      path.join(OUT_DIR, "tokens.experimental.css"),
      [
        fs.readFileSync(path.join(OUT_DIR, "tokens.experimental.light.css"), "utf8"),
        "",
        fs.readFileSync(path.join(OUT_DIR, "tokens.experimental.dark.css"), "utf8"),
        ""
      ].join("\n")
    );
    fs.writeFileSync(
      path.join(OUT_DIR, "tokens.experimental.ts"),
      [
        fs.readFileSync(path.join(OUT_DIR, "tokens.experimental.light.ts"), "utf8"),
        fs.readFileSync(path.join(OUT_DIR, "tokens.experimental.dark.ts"), "utf8"),
        ""
      ].join("\n")
    );
    for (const f of [
      "tokens.experimental.light.css",
      "tokens.experimental.dark.css",
      "tokens.experimental.light.ts",
      "tokens.experimental.dark.ts"
    ]) {
      fs.rmSync(path.join(OUT_DIR, f), { force: true });
    }
  } else {
    await buildExperimentalTheme({
      theme: "single",
      selector: ":root",
      themeFile: HAS_LIGHT_THEME ? LIGHT_THEME_FILE : null,
      exportName: "tokensExperimental"
    });
    fs.renameSync(
      path.join(OUT_DIR, "tokens.experimental.single.css"),
      path.join(OUT_DIR, "tokens.experimental.css")
    );
    fs.renameSync(
      path.join(OUT_DIR, "tokens.experimental.single.ts"),
      path.join(OUT_DIR, "tokens.experimental.ts")
    );
  }
}

// 3) Emit build fingerprint so CI can detect drift
const fingerprint = {
  base: sha256File(CORE_FILES[0]),
  semantic: sha256File(CORE_FILES[1]),
  context: sha256File(CORE_FILES[2]),
  ...(ENABLE_EXPERIMENTAL ? { aliases: sha256File(ALIASES_FILE) } : {}),
  ...(HAS_LIGHT_THEME ? { themeLight: sha256File(LIGHT_THEME_FILE) } : {}),
  ...(HAS_DARK_THEME ? { themeDark: sha256File(DARK_THEME_FILE) } : {})
};

fs.writeFileSync(path.join(OUT_DIR, "tokens.fingerprint.json"), JSON.stringify(fingerprint, null, 2));

console.log("Tokens built successfully.");
